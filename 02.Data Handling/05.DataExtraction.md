# Data Extraction

Data extraction is the process of extracting data from a source, such as a database, a file, or a web page, and storing it in a structured format, such as a database or a file.

---

## Selecting Data Using `loc()` and `iloc()`

### `loc['row_label', 'column_label']`:
- label based, so we have to specify the rows and columns based on their index/row and column labels. <br>

**Value: (one row)**
```python
df.loc['Zero', 'Col1']
# For multiple columns
df.loc['Zero', ['Col1', 'Col2']]
```

**List: (multiple rows)** 
```python
df.loc[['Zero', 'Two'], 'Col1']
# For multiple columns
df.loc[['Zero', 'Two'], ['Col1', 'Col2']]
```

**Slicing: (range of rows)** 
- from the zero label till the two label rows are included
```python
df.loc['Zero':'Two', 'Col1']
# For multiple columns
df.loc['Zero':'Two', ['Col1', 'Col2']]
```

**Conditions:**
```python
df.loc[df['Col1'] > 2000, 'Col2']
# For multiple conditions
df.loc[list((df['Col1'] > 2000) & (df['Col2']== "Hello")), 'Col2']
```

**Setting Value:**
```python
df.loc['Zero', 'Col1'] = 1000
# setting NaN values for a specific row
df.loc['Zero', :] = np.nan
```

### `iloc[row_position, column_position]`
- integer position based, so we have to specify the rows and columns by their integer position values (0-based integer position).  

**Value: (one row)**
```python
df.loc[0, 1]
# For multiple columns
df.loc[0, [1, 2]]
```

**List: (multiple rows)**
```python
df.loc[[0, 2], 1]
# For multiple columns
df.loc[[0, 2], [1, 2]]
```

**Slicing: (range of rows)**
- from the 0 index till before the 2 index are included
```python
df.loc[0:2, 1] 
# For multiple columns
df.loc[0:2, [1, 2]]
```

**Conditions:**
```python
df.iloc[list(df['Col1'] > 2000), 'Col2']
# For multiple conditions
df.iloc[list((df['Col1'] > 2000) & (df['Col2']== "Hello")), 'Col2']
```

**Setting Value:**
```python
df.loc[0, 1] = 1000
# setting NaN values for a specific row
df.loc[0, :] = np.nan
```

---

## Selecting Data Using `query()`

**Single Query:**
```python
df.query('Col1 > 2000')
# In case of boolean slicing
df[df["Col1"]>2000]
```

**Multiple Queries:**
```python
df.query('Col1 > 2000 and Col2 == "Hello"')
# In case of boolean slicing
df[(df["Col1"]>2000) & (df["Col2"]=="Hello")]
```

**Not Operator:**
```python
df.query('not (Col1 > 2000)')
# In case of boolean slicing
df[~(df["Col1"]>2000)]
```

---

## Applying Functions to DataFrames with `apply()`

**Apply Function to a column:**
```python
def square(x):
    return x**2

# Apply the function to a column
df['Col1'] = df['Col1'].apply(square)
```

**Apply Embedded Function to a column**
```python
import numpy as np

df['Col1'].apply(np.square)
```

**Apply Lambda Function to a column:**
```python
df['Col1'].apply(lambda x: x**2)
```

---

## Copy DataFrames using `copy()`

**Copy DataFrame:**
- Any changes to the copy will affect the original DataFrame
```python
df_copy = df
```

**Copy DataFrame with shallow copy:**
- Any changes to the shallow copy will affect the original DataFrame
```python
df_shallow_copy = df.copy(deep=False)
```

**Copy DataFrame with deep copy:**
- Any changes to the deep copy will not affect the original DataFrame
```python
df_deep_copy = df.copy(deep=True)
```

---

## Dealing With Dates

**Conver the data type of the column to datetime:**
```python
df['Date'] = df['Date'].astype('datetime64')
```

**Check the data type of the column:**
```python
df['Date'].type()
```

**Extract the day, month, and year:**
```python
# Day
Days = df['Date'].dt.day
# Month
Months = df['Date'].dt.month
# Year
Years = df['Date'].dt.year
```

**Query with Date**
```python
df.query('Years > 1990')
```

---

## Drop Data
- `axis = 0`: drop row
- `axis = 1`: drop column

### Drop Row

**Axis parameter:**
```python
df.drop("Row1", axis=0)
# For multiple rows
df.drop(["Row1", "Row2"], axis=0)
```

**Index parameter:**
```python
df.drop(index=["Row1"])
# For multiple rows
df.drop(index=["Row1", "Row2"])
```

**Drop by position:**
```python
df.drop(0, axis=0)
# For multiple rows
df.drop([0, 1], axis=0)
```

### Drop Column

**Axis parameter:**
```python
df.drop("Col1", axis=1)
# For multiple columns
df.drop(["Col1", "Col2"], axis=1)
```

**Column parameter:**
```python
df.drop(columns=["Col1"])
# For multiple columns
df.drop(columns=["Col1", "Col2"])
```

**Drop by position:**
```python
df.drop(0, axis=1)
# For multiple columns
df.drop([0, 1], axis=1)
```

### Drop NAN

**Drop rows with any NaN values:**
```python
df.dropna()
```

**Drop rows with all NaN values:**
```python
df.dropna(how="all")
```

**Drop columns with any NaN values:**
```python
df.dropna(axis=1)
```

**Drop columns with all NaN values:**
```python
df.dropna(axis=1, how="all")
```

**Drop rows with NaN values in specific columns:**
```python
df.dropna(subset=["Col1", "Col2"])
```

---

## Random Samples

### Extract random elements from the DataFrame:

**Random number of rows**
```python
df['Col1'].sample(10)
```
**Using random_state for reproducibility**
```python
df['Col1'].sample(10, random_state=99)
```
**Percentage of rows**
```python
df['Col1'].sample(frac=0.2, random_state=99)
```

**Sample up the number of rows of the data**
```python
df.sample(frac=2, random_state=99)
```

---

